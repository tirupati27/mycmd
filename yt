#!/bin/bash
# Author       : Tirupati Bala
# Date         : 25th september 2025
# ================================================================
# Aim          : A simple script to download Videos or Audio from YouTube using yt-dlp.
#                The script provides options to download video, audio, video clip or audio clip.
#                It also allows users to choose the quality of download by specifying format codes.
#                The script is designed to be user-friendly and works in Termux on Android as well
#                as in Linux environments.
# Requirements : yt-dlp must be installed and accessible in the system PATH.
# ================================================================


# ===============================================================
# 1. User-defined functions
# ===============================================================


# usage: choose_download_dir
choose_download_dir() {
    local file="$MYCMD/yt-dirs.txt"
    # ---------------------------------------------------------
    # Create yt-dirs.txt if it doesn't exist, with sample entries
    # ---------------------------------------------------------
    if [[ ! -f "$file" ]]; then
        cat > "$file" <<'dirEOF'
Note:
# ---------------------------------------------
# List your preferred directories to save downloads, one per line.
# The first existing directory in the list will be used as the default.
# Lines starting with '#' are comments and will be ignored.
# Example directories:
$HOME/Music
/sdcard/Music/songs
# ---------------------------------------------
dirEOF
    fi
    # ---------------------------------------------------------
    # Collect valid directories from the file (ignore comments) into an array
    # ---------------------------------------------------------
    local dirs=()
    while IFS= read -r line; do
        # Skip comments, empty lines, and non-existent directories
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        [[ -d "$line" ]] || continue
        dirs+=("$line")
    done < "$file"

    # if the array is empty exit the script
    [[ ${#dirs[@]} -eq 0 ]] && warning_and_exit \
"âŒ None of the preferred directories exist to save downloads.
Please edit '$(text_attr yellow "$file")' to include valid directories."

    # ---------------------------------------------------------
    # Print all available dirs where the first directory is default
    # ---------------------------------------------------------
    local default_dir="${dirs[0]}"
    echo "ðŸ“ Available directories to save downloads:"
    local count=1
    for dir in "${dirs[@]}"; do
        if [[ "$dir" == "$default_dir" ]]; then
            echo "  $count. $dir  (default âœ…)"
        else
            echo "  $count. $dir"
        fi
        ((count++))
    done
    # ---------------------------------------------------------
    # Ask the user if they want to use the default directory
    # ---------------------------------------------------------
    while true; do
        read -p "$(text_attr underline "Choose a directory to save $ACTION [press enter for default]"): " response
        handle_exit "$response"
        local selected_dir
        if [[ -z "$response" ]]; then
            selected_dir="$default_dir" && break
        # Ensure numeric and in range
        elif [[ "$response" =~ ^[0-9]+$ ]] && (( response >= 1 && response <= ${#dirs[@]} )); then
            selected_dir="${dirs[$((response-1))]}" && break
        else
            echo "$(text_attr red "Invalid choice. Please select a number between 1 and ${#dirs[@]}.")"
        fi
    done
    # ---------------------------------------------------------
    # Change to the selected directory
    # ---------------------------------------------------------
    cd "$selected_dir" || warning_and_exit \
"âŒ Failed to change directory to $selected_dir. Please check permissions."
    echo "âœ… Download directory set to: $(pwd)"
}

# usage: text_attr "attr1+attr2+..." "text-to-style"
# attr:- bold, italic, underline, <color-name>, rand_color, bg:<color-name>, bg:rand_color
text_attr() {
  local attr_string="$1"
  local text="$2"
  local esc="\033["
  local reset="${esc}0m"
  local style_codes=""
  local fg_code=""
  local bg_code=""
  # Define RGB values for supported colors
  declare -A colors=(
    [red]="255;0;0"
    [green]="0;255;0"
    [blue]="0;0;255"
    [yellow]="255;255;0"
    [cyan]="0;255;255"
    [magenta]="255;0;255"
    [orange]="255;165;0"
    [purple]="128;0;128"
    [pink]="255;192;203"
    [gray]="128;128;128"
  )
  # Prepare color names array (for random selection)
  local color_names=("${!colors[@]}")
  # Split attributes by '+'
  IFS='+' read -ra attrs <<< "$attr_string"
  for attr in "${attrs[@]}"; do
    case "$attr" in
      bold) style_codes+="1;" ;;
      italic) style_codes+="3;" ;;
      underline) style_codes+="4;" ;;
      rand_color)
        # Random foreground color
        local rand_index=$((RANDOM % ${#color_names[@]}))
        local rand_key="${color_names[$rand_index]}"
        IFS=';' read -r r g b <<< "${colors[$rand_key]}"
        fg_code="${esc}38;2;${r};${g};${b}m"
        ;;
      bg:rand_color)
        # Random background color
        local rand_index=$((RANDOM % ${#color_names[@]}))
        local rand_key="${color_names[$rand_index]}"
        IFS=';' read -r r g b <<< "${colors[$rand_key]}"
        bg_code="${esc}48;2;${r};${g};${b}m"
        ;;
      bg:*)
        # Specific background color
        local bg_color="${attr#bg:}"
        if [[ -n "${colors[$bg_color]}" ]]; then
          IFS=';' read -r r g b <<< "${colors[$bg_color]}"
          bg_code="${esc}48;2;${r};${g};${b}m"
        fi
        ;;
      *)
        # Specific foreground color
        if [[ -n "${colors[$attr]}" ]]; then
          IFS=';' read -r r g b <<< "${colors[$attr]}"
          fg_code="${esc}38;2;${r};${g};${b}m"
        fi
        ;;
    esac
  done
  # Remove trailing semicolon
  style_codes="${style_codes%;}"
  # Combine everything
  local final_code="${esc}${style_codes}m${fg_code}${bg_code}"
  # Print styled text
  echo -e "${final_code}${text}${reset}"
}

# Usage: show_debugInfo_and_exit
show_debugInfo_and_exit() {
    local colors=("red" "green" "blue" "yellow" "cyan")
    local color_name="${colors[RANDOM % ${#colors[@]}]}"
    local attribute="${color_name}+bold"
    local H_line="___________________________________________________________"
    local V_line="|"
    # Define a helper i.e "print_row <key> <value>"
    print_row() {
        printf "%-${max_key_len}s %s %s\n" "$1" "$(text_attr "$attribute" "$V_line")" "$2"
    }
    # Collect all keys (for width calculation)
    local keys=(
        "OS" "yt-dlp version" "User" "PWD" "mycmd package dir."
        "User command" "Selected action" "Downloading from URL"
        "Saving downloads to" "Using format code"
        "File name pattern" "Full yt-dlp command"
    )
    # Compute longest key for column width
    local max_key_len=0
    for k in "${keys[@]}"; do
        (( ${#k} > max_key_len )) && max_key_len=${#k}
    done
    ((max_key_len+=1))
    echo "$(text_attr "$attribute" "$H_line")"
    echo "Debug Info.(Action='$ACTION'):"
    echo "$(text_attr "$attribute" "$H_line")"
    print_row "OS" "$(uname -a)"
    print_row "yt-dlp version" "$(command -v yt-dlp >/dev/null 2>&1 && yt-dlp --version || echo 'yt-dlp not installed')"
    print_row "User" "$USER"
    print_row "PWD" "$(echo $OLDPWD)"
    print_row "mycmd package dir." "$MYCMD"
    echo "$(text_attr "$attribute" "$H_line")"
    print_row "User command" "$user_command"
    print_row "Selected action" "$ACTION"
    print_row "Downloading from URL" "$URL"
    print_row "Saving downloads to" "$(pwd)"
    print_row "Using format code" "$FORMAT_CODE"
    print_row "File name pattern" "$fileName_pattern"
    # Printing full yt-dlp command
    local temp_arr=($ytdlp_command)
    printf "%-${max_key_len}s" "Full yt-dlp Command"
    echo " $(text_attr "$attribute" "$V_line") ${temp_arr[@]}"
    echo "$(text_attr "$attribute" "$H_line")"
    exit 0
}

# function to handle exit when user types 'exit' in any prompt
handle_exit() {
    if [[ "$1" == "exit" ]]; then
        echo "You cancelled the $ACTION download process."
        echo "$(text_attr cyan "Exiting the script.")"
        exit 0
    fi
}
# usage: warning_and_exit <error-message>
warning_and_exit() {
    echo "$(text_attr red "Error:") $1"
    echo -e "\n$(text_attr green "Usage:") yt <action> [url] [--best] [--debug]"
    echo "Try '$(text_attr rand_color "yt --help")' for more information."
    exit 1
}

# usage: prompt_for_url
prompt_for_url() {
    if [[ "$URL" == "NA" ]]; then
        echo -e "\n$(text_attr magenta Note:) you can type 'exit' in any prompt to quit the program.\n"
        echo "URL not provided as argument to download the $ACTION."
        while true; do
            read -p "$(text_attr underline "Enter URL to download the $ACTION"): " URL && handle_exit "$URL"
            [[ -n "$URL" ]] && break || echo "$(text_attr red "Please enter URL for the $ACTION.")"
        done
    fi
}

# Usage: prompt_for_format_code "bv+ba" "[e.g. 18 or 137+140 or bv+ba]"
prompt_for_format_code() {
    if [[ "$FORMAT_CODE" == "best" ]]; then
        FORMAT_CODE=$1
    else
        if command -v yt-dlp >/dev/null 2>&1; then
            clear
            echo "$(text_attr yellow "fetching available formats...to choose for the $ACTION")"
            yt-dlp -F "$URL" || echo "$(text_attr red "Failed to fetch formats from the provided URL.")" && exit 1
            echo -e "\n$(text_attr magenta Note:) you can type 'exit' in any prompt to quit the program.\n"
            while true; do
                read -p "$(text_attr magenta "Enter format code for $ACTION") $2: " FORMAT_CODE && handle_exit "$FORMAT_CODE"
                [[ -n "$FORMAT_CODE" ]] && break || echo "$(text_attr red "Please enter format code to download the $ACTION.")"
            done
        else
            # This block is executed in debug mode
            FORMAT_CODE="neither_'--best'_used_nor_yt-dlp_installed"
        fi
    fi
}

# usage: prompt_for_time_range
prompt_for_time_range() {
    #if [[ "$TIME_RANGE" == "NA" ]]; then
        echo -e "\n$(text_attr magenta Note:) you can type 'exit' in any prompt to quit the program.\n"
        #echo "Time range for $ACTION not provided as argument."
        while true; do
            read -p "$(text_attr underline "Enter time range for $ACTION") [e.g. 00:01:30-00:02:45]: " TIME_RANGE && handle_exit "$TIME_RANGE"
            [[ -n "$TIME_RANGE" ]] && break || echo "$(text_attr red "Please enter time range for the $ACTION.")"
        done
    #fi
}

# usage: final_execution
final_execution() {
$DEBUG_MODE && show_debugInfo_and_exit || \
$ytdlp_command && echo -e "\n$(text_attr green+bold+underline "Downloaded"): File saved as $(pwd)/$fileName_pattern.mp4" || \
echo -e "\n$(text_attr red+bold+underline "Download failed.")" 
}


# ===============================================================
# 2. Parsing the CLI arguments
# ===============================================================

# Default values
ACTION="NA"             # -v, -a, -vc, -ac, --help
URL="NA"                # http://* or https://*
FORMAT_CODE="NA"        # --best
DEBUG_MODE=false        # --debug
for arg in "$@"; do     # Iterating over all CLI arguments
    case "$arg" in
        -v|--video)
            ACTION="video"
            ;;
        -a|--audio)
            ACTION="audio"
            ;;
        -vc|--video-clip)
            ACTION="video-clip"
            ;;
        -ac|--audio-clip)
            ACTION="audio-clip"
            ;;
        --help)
            ACTION="show_help"
            ;;
        --best)
            FORMAT_CODE="best"
            ;;
        http://*|https://*)
            URL="$arg"
            ;;
        --debug)
            DEBUG_MODE=true
            ;;
        *)
            warning_and_exit "Unknown option '$(text_attr cyan "$arg")'"
            ;;
    esac
done
# if required argument i.e. ACTION is not provided, exit the script
if [[ "$ACTION" == "NA" ]]; then
    warning_and_exit "Argument $(text_attr underline "<action>") is required."
fi


# ===============================================================
# 3. Main script logic
# ===============================================================


user_command="yt $@"
# check if yt-dlp is installed and script is not in debug mode
if ! command -v yt-dlp >/dev/null 2>&1 && ! $DEBUG_MODE; then
    warning_and_exit "yt-dlp is not installed, please install it first."
fi

# -------------------- 1. ACTION=="video" ------------------------------

if [[ "$ACTION" == "video" ]]; then
    prompt_for_url
    prompt_for_format_code "bv+ba" "[e.g. 18 or 137+140 or bv+ba]"
    choose_download_dir
    fileName_pattern="%(title)s_%(id)s_%(resolution)s"
    # Set full yt-dlp command
    ytdlp_command="yt-dlp \
                   -f $FORMAT_CODE \
                   -o $fileName_pattern \
                   --merge-output-format mp4 \
                   --embed-thumbnail \
                   --no-playlist \
                   --retries infinite \
                   --fragment-retries 10 \
                   $URL"
    final_execution
fi

# -------------------- 2. ACTION=="audio" ------------------------------

if [[ "$ACTION" == "audio" ]]; then
    prompt_for_url
    prompt_for_format_code "ba" "[e.g. 140 or ba]"
    choose_download_dir
    fileName_pattern="%(title)s_%(id)s_%(resolution)s.mp3"
    # Set full yt-dlp command
    ytdlp_command="yt-dlp \
                   -f $FORMAT_CODE \
                   -o $fileName_pattern \
                   --extract-audio \
                   --embed-thumbnail \
                   --no-playlist \
                   --retries infinite \
                   --fragment-retries 10 \
                   $URL"
    final_execution
fi

# -------------------- 3. ACTION=="video-clip" -------------------------

if [[ "$ACTION" == "video-clip" ]]; then
    prompt_for_url
    prompt_for_format_code "bv" "[e.g. 18 or 137+140 or bv+ba]"
    prompt_for_time_range
    choose_download_dir
    fileName_pattern="%(title)s_%(id)s_%(resolution)s"
    # Set full yt-dlp command
    ytdlp_command="yt-dlp \
                   -f $FORMAT_CODE \
                   -o $fileName_pattern \
                   --merge-output-format mp4 \
                   --download-sections *$time_range \
                   --force-keyframes-at-cuts \
                   --embed-thumbnail \
                   --no-playlist \
                   --retries infinite \
                   --fragment-retries 10 \
                   $URL"
    final_execution
fi

# -------------------- 4. ACTION=="audio-clip" -------------------------

if [[ "$ACTION" == "audio-clip" ]]; then
    prompt_for_url
    prompt_for_format_code "ba" "[e.g. 140 or ba]"
    prompt_for_time_range
    choose_download_dir
    fileName_pattern="%(title)s_%(id)s_%(resolution)s.mp3"
    # Set full yt-dlp command
    ytdlp_command="yt-dlp \
                   -f $FORMAT_CODE \
                   -o $fileName_pattern \
                   --extract-audio \
                   --download-sections *$time_range \
                   --force-keyframes-at-cuts \
                   --embed-thumbnail \
                   --no-playlist \
                   --retries infinite \
                   --fragment-retries 10 \
                   $URL"
    final_execution
fi

# -------------------- 5. ACTION=="show_help" -------------------------

if [[ "$ACTION" == "show_help" ]]; then
    echo \
"It is a simple script to download Videos or Audio from YouTube using yt-dlp.
The script provides options to download video, audio, video clip or audio clip
The $(text_attr underline "download directory can be customized") by modifying the script
It also allows users to choose the quality of download by specifying format codes
The script is designed to be user-friendly and works in Termux on Android as well as in Linux environments.

$(text_attr green "Usage:") yt <action> [url] [--best] [--debug]

There are 5 actions, can be specified using flags:
  1. Download video         : -v or --video
  2. Download audio         : -a or --audio
  3. Download audio clip    : -ac or --audio-clip
  4. Download video clip    : -vc or --video-clip
  5. Show this help message : --help
--best  : (Optional) Download best available format directly, without showing format list
--debug : (Optional) instead of downloading, show debug info and full yt-dlp command

$(text_attr green "Examples:")
  'yt -v --best https://www.youtube.com/watch?v=example'
  'yt -a --best https://www.youtube.com/watch?v=example --debug'
  'yt -ac https://www.youtube.com/watch?v=example'
  'yt -vc https://www.youtube.com/watch?v=example --best'
  'yt --help'"
    exit 0
fi
